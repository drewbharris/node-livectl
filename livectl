#!/usr/bin/env node

"use strict";

var fs = require('fs'),
	when = require('when'),
	sequence = require('sequence'),
	commander = require('commander'),
	midi = require('midi'),
	globalSockets = {};

commander
	.version('0.0.1')
	.option('start', 'start a livectl server')
	.option('connect [address]', 'connect to a livectl server')
	.option('list', 'list available midi devices')
	.parse(process.argv);

if (commander.start) {
	var app = require('express')(),
		express = require('express'),
		server = require('http').createServer(app),
		io = require('socket.io').listen(server);

	console.log('starting server');

	server.listen(8080);

	io.sockets.on('connection', function(socket){
		socket.on('midiEvent', function(data){
			socket.broadcast.emit('midiEvent', data);
		});
	});

	// client route
	app.get('/', function (req, res) {
		var ua = req.header('user-agent');
		if (/mobile/i.test(ua)) {
		return res.sendfile(__dirname + '/slave_mobile.html');
		}
		return res.sendfile(__dirname + '/slave.html');
	});
}
else if (typeof commander.connect === 'string') {
	var app = require('express')(),
		express = require('express'),
		server = require('http').createServer(app),
		io = require('socket.io-client'),
		midiInput = new midi.input(),
		midiOutput = new midi.output(),
		nickname,
		input,
		output;

	sequence().then(function(next){
		listPorts(midiInput, midiOutput).then(next);
	}).then(function(next){
		commander.prompt('enter a name for this computer: ', next);
	}).then(function(next, nicknameChoice){
		nickname = nicknameChoice;
		next();
	}).then(function(next){
		commander.prompt('input (enter for none): ', next);
	}).then(function(next, inputChoice){
		input = inputChoice;
		next();
	}).then(function(next){
		commander.prompt('output (enter for none): ', next);
	}).then(function(next, outputChoice){
		output = outputChoice;
		next();
	}).then(function(next){
		if (input) {
			console.log('opening midi input ' + input);
			midiInput.openPort(parseInt(input, 10));
		}
		else {
			// console.log('opening virtual midi input ' + nickname + '-input');
			// midiInput.openVirtualPort(nickname + '-input');
		}
		if (output) {
			console.log('opening midi output ' + output);
			midiOutput.openPort(parseInt(output, 10));
		}
		else {
			// console.log('opening virtual midi output ' + nickname + '-output');
			// midiInput.openVirtualPort(nickname + '-output');
		}
		if (input === undefined && output === undefined) {
			console.log('need to select an input or output');
			process.exit(0);
		}
		next();
	}).then(function(next){
		console.log('connecting to ' + commander.connect);

		var socket = io.connect(commander.connect);
		socket.on('midiEvent', function(data){
			console.log(data);
			if (output !== undefined) {
				midiOutput.sendMessage(data.midiMessage);
			}
		});

		midiInput.on('message', function(deltaTime, message){
			console.log(message, ' ', deltaTime);
			if (input !== undefined) {
				socket.emit('midiEvent', {
					'midiMessage': message,
					'deltaTime': deltaTime,
					'client': nickname
				});
			}
		});


	});

	// midiInput.close();
	// midiOutput.close();

}
else if (commander.list) {
	listPorts(new midi.input(), new midi.output());
	process.exit(0);
}
else {
	commander.outputHelp();
}

function listPorts(input, output) {
	var d = when.defer(),
		numberOfInputs = input.getPortCount(),
		numberOfOutputs = output.getPortCount();
	console.log('Inputs:');
	for (var i=0;i<numberOfInputs;i++) {
		console.log(i + ': ' + input.getPortName(i));
	}
	console.log('Outputs:');
	for (i=0;i<numberOfOutputs;i++) {
		console.log(i + ': ' + output.getPortName(i));
	}
	d.resolve();
	return d.promise;
}

